---
title: 缓存
date: 2020-11-20 09:33:27
tags: 软技能
---
### 强缓存和协商缓存
强缓存和协商缓存两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。

<!--more-->

#### 强缓存
强缓存主要是通过http请求头中的Cache-Control和Expire两个字段控制。Expire是HTTP1.0标准下的字段。

一般，设置Cache-Control的值为“public, max-age=xxx”，表示在xxx秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。

如果在xxx秒内，服务器上面的资源更新了，客户端在没有强制刷新的情况下，看到的内容还是旧的。如果发布新版本的时候，后台接口也同步更新了，有缓存的用户还在使用旧接口，而那个接口已经被后台干掉了。这个时候就会出现问题

#### 协商缓存
协商缓存最大的问题就是每次都要向服务器验证一下缓存的有效性，但是，每次都去请求服务器，那要缓存还有什么意义。

### 总结
缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，应该是尽可能用强缓存，同时，能在更新版本的时候让客户端的缓存失效。

在更新版本之后，可以在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。

这个时候webpack就可以让我们在打包的时候，在文件的命名上带上hash值。
```
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react', 'antd']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}
```
综上所述，我们可以得出一个较为合理的缓存方案：

- HTML：使用协商缓存。
- CSS&JS&图片：使用强缓存，文件命名带上hash值。

webpack提供了三种哈希值计算方式，分别是hash、chunkhash和contenthash。

- hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。
- chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。
- contenthash：由文件内容产生的hash值，内容不同产生的contenthash值也不一样。
